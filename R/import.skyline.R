#' Import function for the SkyLine2D system linked to one GHG analyzer
#'
#' Imports single raw gas measurement files from the SkyLine2D system from
#' Earth Bound Scientific from the datalog file created by GAIA2TECH. Default
#' settings are set for the Picarro G2508
#' (\ifelse{html}{\out{CO<sub>2</sub>}}{\eqn{CO[2]}{ASCII}},
#' \ifelse{html}{\out{CH<sub>4</sub>}}{\eqn{CH[4]}{ASCII}},
#' \ifelse{html}{\out{N<sub>2</sub>O}}{\eqn{N[2]O}{ASCII}} and
#' \ifelse{html}{\out{H<sub>2</sub>O}}{\eqn{H[2]O}{ASCII}}), to match the
#' example data file provided with the package.
#'
#' @param inputfile character string; the name of a file with the extension .csv
#' @param date.format character string; specifies the date format found in the
#'                    raw data file. Choose one of the following: "dmy", "ymd",
#'                    or "mdy". Default is "ymd", as it is the date format from
#'                    the example data file provided.
#' @param timezone character string; a time zone in which to import the data to
#'                 POSIXct format. Default is "UTC". Note about time zone: it is
#'                 recommended to use the time zone "UTC" to avoid any issue
#'                 related to summer time and winter time changes.
#' @param save logical; if \code{save = TRUE}, saves the file as an .RData file
#'             in a RData folder in the current working directory. If
#'             \code{save = FALSE}, returns the file in the Console, or load in
#'             the Environment if assigned to an object.
#' @param keep_all logical; if \code{keep_all = TRUE}, keep all columns from the raw
#'                 file. The default is \code{keep_all = FALSE}, and columns that
#'                 are not necessary for gas flux calculation are removed.
#' @param deadband numerical; define a deadband at the start of measurements (seconds).
#' @param shoulder numerical; include background data points before and after
#'                 the measurement (seconds).
#' @param CH.clo.col,CH.col character string; a pattern to match columns that
#'        fit the corresponding parameters: \code{CH.col = "CH ID"} and
#'        \code{CH.clo.col = "Chamber closed"}.
#' @param inst character string; a pattern to match the column containing the
#'        name of the GHG analyzer: \code{inst = "Instrument"}.
#' @param sensor1,sensor2 character strings; a pattern to match the columns
#'        containing the name of each sensor. By default,
#'        \code{sensor1 = "Analog Sensor1"}, \code{sensor2 = "Analog Sensor2"},
#'        to match the example data file provided with the package. Set to NULL
#'        to ignore these columns.
#' @param gas character vector; a pattern to match the columns containing each
#'        gas measurement. By default, \code{gas = c("CO2", "CH4 Dry", "N2O Dry", "H2O")},
#'        to match the example data file provided with the package.
#' @param prec numerical vector; the precision of the instrument for each gas
#'        mentioned in \code{gas}. By default, \code{prec = c(0.24, 0.3, 5, 500)},
#'        to match the example data file provided with the package. Note that
#'        the order in the arguments \code{prec} must match the order of the
#'        arguments in \code{gas}.
#' @param dry logical; are the gas measurements compensated for water vapor
#'        (dry fraction)? If \code{dry = TRUE} (default), the gases are already
#'        compensated for water vapor. Otherwise, the gases will be converted to
#'        a dry fraction.
#'
#' @returns A data frame containing raw data from the SkyLine2D system
#'
#' @details
#' This function has been designed for the SkyLine2D system file generated by
#' GAIA2TECH synced with the Picarro G2508
#' (\ifelse{html}{\out{CO<sub>2</sub>}}{\eqn{CO[2]}{ASCII}},
#' \ifelse{html}{\out{CH<sub>4</sub>}}{\eqn{CH[4]}{ASCII}},
#' \ifelse{html}{\out{N<sub>2</sub>O}}{\eqn{N[2]O}{ASCII}} and
#' \ifelse{html}{\out{H<sub>2</sub>O}}{\eqn{H[2]O}{ASCII}})). If this function
#' could be useful for you, but does not meet your needs, please contact the
#' maintainer of this package for potential adaptations.
#'
#' In \code{date.format}, the date format refers to a date found in the raw data
#' file, not the date format in the file name. For the SkyLine2D system,
#' the date is found in the column "Titles:". Be mindful that when you open a
#' .csv file in Excel, the software often changes date formats. To avoid any
#' discrepancy, open the file in a text file.
#'
#' The argument \code{CH.clo.col} corresponds to the column "Chamber closed".
#' Any number above 0 in that column indicate that the chamber is closed. The
#' argument \code{CH.col} corresponds to the column "CH ID" indicating which
#' chamber is active.
#'
#' For each gas, the units are taken from the second row in the raw file (Units:).
#' If your instrument uses different units, either convert the units after
#' import, change the settings on your instruments, or contact the maintainer of
#' this package for support.
#'
#' Regarding the parameters \code{dry}, in case of uncertainty, either contact
#' your technical support or assume that gases are compensated for water vapor,
#' which is normally the case.
#'
#' As opposed to the other import functions, there is no option to "keep_all" with
#' this instrument. If you would like to import additional data using this
#' function, please contact the maintainer of this package for support.
#'
#' The precision of the instrument is needed to restrict kappa-max
#' (\code{\link[goFlux]{k.max}}) in the non-linear flux calculation
#' (\code{\link[goFlux]{HM.flux}}). Kappa-max is inversely proportional to
#' instrument precision. If the precision of your instrument is unknown, it is
#' better to use a low value (e.g. 1 ppm for
#' \ifelse{html}{\out{CO<sub>2</sub>}}{\eqn{CO[2]}{ASCII}} and
#' \ifelse{html}{\out{H<sub>2</sub>O}}{\eqn{H[2]O}{ASCII}}, or 1 ppb for
#' \ifelse{html}{\out{CH<sub>4</sub>}}{\eqn{CH[4]}{ASCII}} and
#' \ifelse{html}{\out{N<sub>2</sub>O}}{\eqn{N[2]O}{ASCII}}) to allow for more
#' curvature, especially for water vapor fluxes, or very long measurements, that
#' are normally curved. The default values given for instrument precision are
#' the ones found online for the latest models of the
#' \href{https://www.picarro.com/environmental/products/g2508_gas_concentration_analyzer}{Picarro G2508},
#' available at the time of the creation of this function (10-2025).
#'
#' @include goFlux-package.R
#'
#' @seealso Use the wrapper function \code{\link[goFlux]{import2RData}}
#'          to import multiple files from the same folder path using any instrument.
#' @seealso See also, import functions for other instruments:
#'          \code{\link[goFlux]{import.DX4015}},
#'          \code{\link[goFlux]{import.EGM5}},
#'          \code{\link[goFlux]{import.G2201i}},
#'          \code{\link[goFlux]{import.G2508}},
#'          \code{\link[goFlux]{import.G4301}},
#'          \code{\link[goFlux]{import.GAIA}},
#'          \code{\link[goFlux]{import.GasmetPD}},
#'          \code{\link[goFlux]{import.GT5000}},
#'          \code{\link[goFlux]{import.HT8850}},
#'          \code{\link[goFlux]{import.LI6400}},
#'          \code{\link[goFlux]{import.LI7810}},
#'          \code{\link[goFlux]{import.LI7820}},
#'          \code{\link[goFlux]{import.LI8100}},
#'          \code{\link[goFlux]{import.LI8200}},
#'          \code{\link[goFlux]{import.LI8250}},
#'          \code{\link[goFlux]{import.N2OM1}},
#'          \code{\link[goFlux]{import.N2Oi2}},
#'          \code{\link[goFlux]{import.uCH4}},
#'          \code{\link[goFlux]{import.uN2O}},
#'          \code{\link[goFlux]{import.UGGA}}
#'
#' @seealso See \code{\link[base]{timezones}} for a description of the underlying
#'          timezone attribute.
#'
#' @examples
#' # Load file from downloaded package
#' file.path <- system.file("extdata", "skyline/skyline.csv", package = "goFlux")
#'
#' # Run function
#' imp.skyline <- import.skyline(inputfile = file.path)
#' @export

import.skyline <- function(inputfile, date.format = "ymd", timezone = "UTC",
                           save = FALSE,
                           keep_all = FALSE,
                           deadband = 0,
                           shoulder = 20,
                           CH.col = "CH ID",
                           CH.clo.col = "Chamber closed",
                           sensor1 = "Analog Sensor1",
                           sensor2 = "Analog Sensor2",
                           inst = "Instrument",
                           gas = c("CO2", "CH4 Dry", "N2O Dry", "H2O"),
                           prec = c(0.24, 0.3, 5, 500),
                           dry = T){

  # Check arguments ####
  if(missing(inputfile)) stop("'inputfile' is required")
  if(!is.character(inputfile)) stop("'inputfile' must be of class character")
  if(length(date.format) != 1) stop("'date.format' must be of length 1")
  if (!is.character(date.format)) stop("'date.format' must be of class character")
  if (!any(grepl(date.format, c("ymd", "dmy", "mdy")))) {
    stop("'date.format' must be one of the following: 'ymd', 'dmy' or 'mdy'")}
  if(!is.character(timezone)) stop("'timezone' must be of class character")
  if(save != TRUE & save != FALSE) stop("'save' must be TRUE or FALSE")
  if (keep_all != TRUE & keep_all != FALSE) stop("'keep_all' must be TRUE or FALSE")
  if(!is.numeric(deadband)) stop("'deadband' must be of class numeric")
  if(!is.numeric(shoulder)) stop("'shoulder' must be of class numeric")
  if(shoulder < 0) stop("'shoulder' must be greater or equal to 0")

  # Column names
  if(is.null(CH.col)) stop("'CH.col' is required")
  if(!is.null(CH.col)) if(!is.character(CH.col)) stop("'CH.col' must be of class character")
  if(!is.null(CH.clo.col)) if(!is.character(CH.clo.col)) stop("'CH.clo.col' must be of class character")

  if(!is.null(sensor1)) if(!is.character(sensor1)) stop("'sensor1' must be of class character")
  if(!is.null(sensor2)) if(!is.character(sensor2)) stop("'sensor2' must be of class character")

  # inst
  if(is.null(inst)) stop("'inst' is required")
  if(!is.character(inst)) stop("'inst' must be of class character")
  if(length(inst) != 1) stop("'inst' must be of length 1")

  # gas
  if(!is.null(gas)) if(!is.character(gas)) stop("'gas' must be of class character")

  # prec
  if(!is.null(prec)) {
    if(!is.numeric(prec)) stop("'prec' must be of class numeric")
    if(length(gas) != length(prec)) stop("'prec' must be the same length as 'gas'")}

  # Assign NULL to variables without binding ####
  CH <- CH.clo <- DATE_TIME <- Obs <- Titles. <- activ.cham <- cham.close <-
    cham.open <- chamID <- dry.log <- flag <- start.time <- POSIX.time <-
    import.error <- POSIX.warning <- N2Odry_ppm <- CH4dry_ppm <- DATE <-
    end.time <- UniqueID <- . <- NULL

  # Input file name
  inputfile.name <- gsub(".*/", "", inputfile)

  # Try to load data file ####
  try.import <- tryCatch(
    {read.delim(inputfile, skip = 1, sep = "\t", colClasses = "character", skipNul = T)},
    error = function(e) {import.error <<- e}
  )

  if(inherits(try.import, "simpleError")){
    warning("Error occurred in file ", inputfile.name, ":\n", "   ",
            import.error, call. = F)
  } else {

    # Replace spaces in column names with a dot to match imported data frame
    if(!is.null(sensor1)){
      sensor12 <- grep(gsub(" ", ".", sensor1, fixed = T),
                       names(try.import), value = T)} else {sensor12 <- "NA"}
    if(!is.null(sensor2)){
      sensor22 <- grep(gsub(" ", ".", sensor2, fixed = T),
                       names(try.import), value = T)} else {sensor22 <- "NA"}

    # Column names match CH.col?
    CH.col2 <- grep(gsub(" ", ".", CH.col, fixed = T), names(try.import), value = T)
    if(!any(grepl(CH.col2, names(try.import)))) {
      stop(paste("Failed to import ", inputfile.name, ". The matching string ",
                 "for chamber ID (CH.col) was not found in column names.", sep =""))}

    # Operating status missing?
    CH.clo.col2 = grep(gsub(" ", ".", CH.clo.col, fixed = T), names(try.import), value = T)
    if(!any(grepl(CH.clo.col2, names(try.import)))){
      warning(paste("In the file", inputfile.name, "the matching string for Operating",
                    "status (CH.clo.col) was not found in column names. By default,",
                    "Operating Status was set to 2 (Chamber Idle Open) for all measurements."),
              call. = F)}

    ## Match column names with instruments and gases? ####

    ## instruments
    if(!is.null(inst)){
      inst2 <- grep(gsub(" ", ".", inst, fixed = T), names(try.import), value = T)
      if(!any(grepl(inst2, names(try.import)))){
        stop(paste("Failed to import ", inputfile.name, ". The matching string ",
                   "for inst '", inst, "' was not found in column names.", sep =""))}}

    ## gas
    gas2 <- NULL; if(!is.null(gas)){
      for(i in 1:length(gas)){
        gas2[i] <- grep(gsub(" ", ".", gas[i], fixed = T), names(try.import), value = T)
        if(!is.na(gas[i])) if(!any(grepl(gas2[i], names(try.import)))){
          stop(paste("Failed to import ", inputfile.name, ". The matching ",
                     "string for gas '", gas[i], "' was not found in ",
                     "column names.", sep =""))}}}

    # FUNCTION STARTS ####

    # Rename gas columns
    units.ls <- list()
    for(i in 1:length(gas)){
      units.ls[[i]] <- select(try.import, all_of(gas2[i]))[[1]][1]}

    gas.col <- cbind.data.frame(gas.col = gas2,
                                units = unlist(units.ls),
                                prec.col = prec) %>%
      mutate(gas = sub("\\..*", "", gas.col)) %>%
      mutate(gas = sub(".*_", "", gas)) %>%
      mutate(dry.log = rep(dry, length((gas))),
             dry = if_else(dry.log, "dry", "wet")) %>%
      mutate(dry = if_else(grepl("H2O", gas), "", dry),
             new.name = paste(gas, dry, "_", units, sep = "")) %>%
      mutate(prec.name = paste(gas, "_prec", sep = ""))

    # Rename gas columns
    data.raw <- try.import
    for(i in 1:nrow(gas.col)){
      data.raw <- data.raw %>%
        setNames(gsub(gas.col$gas.col[i], gas.col$new.name[i], names(.)))}

    # Import raw data file from skyline (.csv)
    data.raw <- data.raw %>%
      # Remove first row containing units
      filter(!Titles. == 'Units:') %>%
      # Modify useful column names
      setNames(gsub(CH.col2, "CH", names(.))) %>%
      setNames(gsub(sensor12, "Sensor1", names(.))) %>%
      setNames(gsub(sensor22, "Sensor2", names(.))) %>%
      setNames(gsub(CH.clo.col2, "CH.clo", names(.))) %>%
      # Extract information about active chambers
      mutate(CH.clo = as.numeric(CH.clo),
             flag = if_else(CH.clo > 0, 1, 0)) %>%
      mutate(activ.cham = if_else(flag == 1, CH, "Background")) %>%
      dplyr::rename(DATE_TIME = Titles.) %>%
      # Detect new observations (Obs) and give a chamber UniqueID (chamID)
      arrange(DATE_TIME) %>%
      # Convert column class automatically
      type.convert(as.is = TRUE) %>%
      # Make sure that all gas data are class numerical
      mutate_at(gas.col$new.name, as.numeric)

    # Keep only useful columns for gas flux calculation
    if(keep_all == FALSE){
      data.raw <- data.raw %>%
        select(contains(c("DATE_TIME", "activ.cham", "CH.clo", "ppb", "ppm", "%",
                          "Sensor1", "Sensor2", "flag")))}

    # Convert H2O_% to ppm
    if(any(grepl("%", gas.col$units))){
      humidity.cols <- select(data.raw, contains("%")) %>%
        mutate_all(~.*10000) %>% setNames(gsub("%", "ppm", names(.)))

      data.raw <- cbind.data.frame(data.raw, humidity.cols)

      if(keep_all == FALSE) data.raw <- select(data.raw, -contains("%"))
    }

    # Compensate for water vapor
    if(any(grepl("wet", gas.col$dry))){
      wet.cols <- select(data.raw, contains("wet")) %>%
        mutate_all(~./(1-H2O_ppm/1000000)) %>%
        setNames(gsub("wet", "dry", names(.)))

      data.raw <- cbind.data.frame(data.raw, wet.cols)

      if(keep_all == FALSE) data.raw <- select(data.raw, -contains("wet"))
    }

    # Convert CH4 and N2O ppm to ppb
    if(any(grepl("CH4dry_ppm", names(data.raw)))){
      data.raw <- data.raw %>% mutate(CH4dry_ppb = CH4dry_ppm*1000)

      if(keep_all == FALSE) data.raw <- select(data.raw, -contains("CH4dry_ppm"))
    }

    if(any(grepl("N2Odry_ppm", names(data.raw)))){
      data.raw <- data.raw %>% mutate(N2Odry_ppb = N2Odry_ppm*1000)

      if(keep_all == FALSE) data.raw <- select(data.raw, -contains("N2Odry_ppm"))
    }

    # Create a new column containing date and time (POSIX format)
    tryCatch(
      {op <- options()
      options(digits.secs=6)
      if(date.format == "dmy"){
        try.POSIX <- as.POSIXct(dmy_hms(data.raw$DATE_TIME, tz = timezone),
                                format = "%Y-%m-%d %H:%M:%OS")
      } else if(date.format == "mdy"){
        try.POSIX <- as.POSIXct(mdy_hms(data.raw$DATE_TIME, tz = timezone),
                                format = "%Y-%m-%d %H:%M:%OS")
      } else if(date.format == "ymd"){
        try.POSIX <- as.POSIXct(ymd_hms(data.raw$DATE_TIME, tz = timezone),
                                format = "%Y-%m-%d %H:%M:%OS")}
      options(op)}, warning = function(w) {POSIX.warning <<- "date.format.error"}
    )

    if(isTRUE(POSIX.warning == "date.format.error")){
      warning("Error occurred in file ", inputfile.name, ":\n",
              "   An error occured while converting DATE and TIME into POSIX.time.\n",
              "   Verify that the 'date.format' you specified (", date.format,
              ") corresponds to the\n",
              "   column 'DATE' in the raw data file. Here is a sample: ",
              data.raw$DATE_TIME[1], "\n", call. = F)
    } else {

      data.raw$POSIX.time <- try.POSIX
      data.raw <- data.raw %>% mutate(DATE = substr(POSIX.time, 0, 10))

      # Calculate chamber closure and chamber opening
      data.raw <- mutate(data.raw, Obs = rleid(activ.cham)) %>%
        mutate(chamID = paste(activ.cham, Obs, sep="_"))

      data.time <- data.raw %>%
        select(activ.cham, chamID, flag, POSIX.time) %>%
        filter(flag == 1) %>% group_by(activ.cham, chamID) %>%
        summarise(cham.close = first(POSIX.time),
                  cham.open = last(POSIX.time)) %>% ungroup() %>%
        mutate(start.time = cham.close + deadband) %>%
        mutate(UniqueID = paste(activ.cham, start.time, sep="_"))

      # Include shoulder ####
      if(shoulder > 0){

        # Create a window of observation for each measurement
        time_range <- data.time %>% group_by(UniqueID) %>%
          reframe(cham.close = cham.close,
                  cham.open = cham.open,
                  time_min = cham.close - shoulder,
                  time_max = cham.open + shoulder)

        time_filter.ls <- list()
        for (i in 1:nrow(time_range)) {
          time_filter.ls[[i]] <- cbind.data.frame(
            UniqueID = time_range$UniqueID[[i]],
            cham.close = time_range$cham.close[[i]],
            cham.open = time_range$cham.open[[i]],
            start.time = time_range$cham.close[[i]] + deadband,
            end.time = time_range$cham.open[[i]],
            POSIX.time = seq(from = time_range$time_min[[i]],
                             to = time_range$time_max[[i]],
                             by = 'sec'))
        }

        time_filter <- map_df(time_filter.ls, ~as.data.frame(.x)) %>%
          # Calculate Etime and flag
          mutate(Etime = as.numeric(POSIX.time - start.time, units = "secs")) %>%
          mutate(flag = if_else(between(POSIX.time, start.time, end.time), 1, 0)) %>%
          mutate(obs.length = as.numeric(end.time - start.time, units = "secs")) %>%
          # Add arguments
          mutate(deadband = deadband, shoulder = shoulder)

        data.raw <- select(data.raw, -flag) %>%
          full_join(time_filter, relationship = "many-to-many", by = "POSIX.time") %>%
          drop_na(DATE) %>%
          drop_na(UniqueID)
      }

      # Exclude background ####
      if(shoulder == 0){
        # Calculate Etime and create UniqueID
        Etime <- filter(data.raw, !grepl("Background", activ.cham)) %>%
          full_join(data.time, by = c("chamID", "activ.cham")) %>%
          select(POSIX.time, chamID, UniqueID, start.time, cham.close, cham.open) %>%
          group_by(chamID) %>%
          mutate(Etime = as.numeric(POSIX.time - start.time, units = "secs")) %>%
          ungroup()

        # Merge data
        data.raw <- data.raw %>% full_join(Etime, by = c("chamID", "POSIX.time")) %>%
          drop_na(UniqueID)

      }

      # Add instrument precision for each gas
      data.raw[gas.col$prec.name] <- 1
      for(i in 1:nrow(gas.col)){
        data.raw <- data.raw %>%
          mutate_at(gas.col$prec.name[i], ~gas.col$prec.col[i])}

      # Add column for instrument
      if(!is.null(inst)) data.raw$inst <- select(try.import, all_of(inst2))[[1]][1]

      ## Warn if there is no match with unnecessary columns ####
      # Sensor1
      if(!any(grepl(sensor12, names(try.import)))){
        warning(paste("In the file ", inputfile.name, " the matching string for ",
                      "sensor1 '", sensor1, "' was not found in column names.",
                      sep = ""), call. = F)}

      # Sensor2
      if(!any(grepl(sensor22, names(try.import)))){
        warning(paste("In the file ", inputfile.name, " the matching string for ",
                      "sensor2 '", sensor2, "' was not found in column names.",
                      sep = ""), call. = F)}

      # Warning if file has no data
      if(nrow(data.raw) == 0){
        warning(paste(inputfile.name, "was imported succesfully, but no",
                      "measurements were detected."), call. = F)
      }

      # Save cleaned data file
      if(save == TRUE){
        # Create RData folder in working directory
        RData_folder <- paste(getwd(), "RData", sep = "/")
        if(dir.exists(RData_folder) == FALSE){dir.create(RData_folder)}

        # Create output file: change extension to .RData, and
        # add instrument name and "imp" for import to file name
        if(grepl("\\.csv", inputfile.name)){
          file.name <- gsub(".*/", "", sub("\\.csv", "", inputfile))
        } else file.name <- inputfile.name
        outputfile <- paste("skyline_", file.name, "_imp.RData", sep = "")

        save(data.raw, file = paste(RData_folder, outputfile, sep = "/"))

        message(inputfile.name, " saved as ", outputfile,
                " in RData folder, in working directory\n", sep = "")
      }

      if(save == FALSE){
        return(data.raw)
      }
    }
  }
}
